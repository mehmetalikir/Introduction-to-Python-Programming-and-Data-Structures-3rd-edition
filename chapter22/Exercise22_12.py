# Author: Hidir Sezgin, Mehmet A. Kir# Email : hidirsezgin@gmail.com, m.kir@student.unsw.edu.au# GitHub: /hidirsezgin, /mehmetalikir'''(4 x 4 16 tail model) The nine tail problem in the text uses a 3 x 3 matrixAssume that you have 16 coins placed in a 4 x 4 matrix. Create a new modeelclass named TailModel16. Create an instance of the model and save the onjectinto a file named 22_12.dat'''from Graph import GraphNUMBER_OF_NODES = 2 ** 16class TailModel16:    def __init__(self):        edges = self.getEdges()        # Create a graph        vertices = [x for x in range(NUMBER_OF_NODES)]        graph = Graph(vertices, edges)        # Obtain a BFS tree rooted at the target node        self.tree = graph.bfs(NUMBER_OF_NODES - 1)    def getShortestPath(self, nodeIndex):        return self.tree.getPath(nodeIndex)    @staticmethod    def printNode(node):        for i in range(16):            if i % 4 != 3:                print(node[i], end=" ")            else:                print(node[i])        print()    @staticmethod    def getEdges():        edges = []  # Store edges        for u in range(NUMBER_OF_NODES):            for k in range(16):                node = TailModel16.getNode(u)  # Get the node for vertex u                if node[k] == 'H':                    v = TailModel16.getFlippedNode(node, k)                    # Add edge (v, u) for a legal move from node u to node v                    edges.append([v, u])        return edges    @staticmethod    def getFlippedNode(node, position):        row = position // 4        column = position % 4        TailModel16.flipACell(node, row, column)        TailModel16.flipACell(node, row - 1, column)        TailModel16.flipACell(node, row + 1, column)        TailModel16.flipACell(node, row, column - 1)        TailModel16.flipACell(node, row, column + 1)        return TailModel16.getIndex(node)    @staticmethod    def getIndex(node):        result = 0        for i in range(16):            if node[i] == 'T':                result = result * 2 + 1            else:                result = result * 2 + 0        return result    @staticmethod    def flipACell(node, row, column):        if 0 <= row < 4 and 0 <= column < 4:            if node[row * 4 + column] == 'H':                node[row * 4 + column] = 'T'  # Flip from H to T            else:                node[row * 4 + column] = 'H'  # Flip from T to H    @staticmethod    def getNode(index):        result = [' ' for _ in range(16)]        for i in range(16):            digit = index % 2            if digit == 0:                result[15 - i] = 'H'            else:                result[15 - i] = 'T'            index = index // 2        return resultdef main():    # Create the TailModel16    model = TailModel16()    # Save the model object to a file    with open('Exercise22_12.dat', 'wb') as file:        import pickle        pickle.dump(model, file)    print("Model object saved to Exercise22_12.dat")if __name__ == '__main__':    main()